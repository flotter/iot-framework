#!/bin/bash -e

CPWD="$( cd "$(dirname "$0")" ; pwd -P )"

#----------------------------------------------------#
# COMMON ATTRIBUTES                                  #
#----------------------------------------------------#

source $CPWD/scripts/iot-utils

#----------------------------------------------------#
# DEFINES / MACROS                                   #
#----------------------------------------------------#

LOG=$MASTER_DB/iot-firmware-commission.log

#----------------------------------------------------#
# CMDLINE OPTIONS                                    #
#----------------------------------------------------#

ARGC=$#
ARGV=("$@")

VERBOSE=false
HELP=false
DEBUG_SHELL=false
SKIP_PAYLOAD=false


# Clear args
set --

COUNT=0
while [ $COUNT -lt $ARGC ]; do
	STRIP=${ARGV[COUNT]}

	ID=0
	LONGFORMAT=`echo $STRIP | cut -b 1-2`
	if [ "x$LONGFORMAT" == "x--" ]; then
		STRIP=`echo ${ARGV[COUNT]} | cut -b 2-3`
	else
		ID=`echo $STRIP | cut -b 3-`
		STRIP=`echo $STRIP | cut -b 1-2`
	fi
	

	if [ "x$STRIP" == "x-v" ]; then
		VERBOSE=true
	elif [ "x$STRIP" == "x-h" ]; then
		HELP=true
	elif [ "x$STRIP" == "x-d" ]; then
		DEBUG_SHELL=true
	elif [ "x$STRIP" == "x-s" ]; then
		SKIP_PAYLOAD=true
	else
		pl
		pr "Error: Unknown argument"
		COUNT=$ARGC
		HELP=true
	fi
COUNT=$((COUNT+1))
done

log "Started"

pl
pg "iot-firmware-commission ($VERSION)"

if [ "$HELP" == "true" ]; then
	pn "Usage:"
	pl
	pn "Commission existing firmware image for specific domain."
	pl
	pn "iot-firmware-commission [-v] [-h] ..."
	pl
	pn "Help:"
	pl
	pn "-v (--verbose)      Verbose output for operations"
	pn "-h (--help)         Print this"
	pn "-d (--debug-shell)  Interactive shell"
	pn "-s (--skip-payload) Payload will be updated when the unit is live"
	pl
	exitbuild
fi

#----------------------------------------------------#
# PREPARE                                            #
#----------------------------------------------------#

pn
pg ":: Setup & Checks ::"
pn

common_setup

log "Common Setup OK"

pnn "- Admin mode enabled : "
ADMIN=$(admin)
if [ "x$ADMIN" == "x1" ]; then
	pg "Yes"
else
	pg "No"
fi

#----------------------------------------------------#
# BODY                                               #
#----------------------------------------------------#

pl
pg ":: Device Selection ::"
pl

DEVICE=$(device)

if [ -z "$DEVICE" ] || [ ! -d $IOT_DEVICE_DIR/$DEVICE ]; then

	if [ "x$ADMIN" == "x1" ]; then

		select_device
	else
		pl
		pr "No default device is set. Without Admin mode we cannot proceed."
		pl
		exit 1
	fi
else
	# Default device (Non-admin mode compatible)
	pn "Default device selected : $DEVICE"
fi

pl
pg ":: Firmware Selection ::"
pl

select_remote_fw "*** Select locally built firmware instead ***"
pl

if [ ! -z "$FIRMWARE_REMOTE" ]; then

	pnn "- Remote Firmware : "
	pg "$S3_DEVICE_FW/$DEVICE/$FIRMWARE_REMOTE.tar.gz"

	pnn "- Firmware Downloading : "
	run mkdir -p $IOT_DOWNLOAD_DIR
	run rm -rf $IOT_DOWNLOAD_DIR/$FIRMWARE_REMOTE.tar.gz
	download_remote_fw_check "$S3_DEVICE_FW/$DEVICE/$FIRMWARE_REMOTE.tar.gz" $IOT_DOWNLOAD_DIR/
	pg "Done"

	pnn "- Firmware Decompressing : "
	run mkdir -p $IOT_FW_DIR
        run rm -rf $IOT_FW_DIR/$FIRMWARE_REMOTE
        run tar xvzf $IOT_DOWNLOAD_DIR/$FIRMWARE_REMOTE.tar.gz -C $IOT_FW_DIR/
	RET=$?
	if [ $RET -ne 0 ]; then
                pr "Fail"
                pl
                pr "Failed to decompress remote firmware (Ret: $RET)"
                pl

                exit 1
        fi
	pg "Done"

	pnn "- Ready for commissioning : "
	run rm -rf $IOT_FW_DIR/tmp.img
	mv $IOT_FW_DIR/$FIRMWARE_REMOTE $IOT_FW_DIR/tmp.img
	FIRMWARE_NAME_FINAL=$IOT_FW_DIR/$DEVICE/$FIRMWARE_REMOTE
	FIRMWARE_NAME=$IOT_FW_DIR/tmp.img
	pg "Yes"
else
	select_local_fw
	pl
	
	pnn "- Local Firmware : "
	pg "$IOT_BUILD_DIR/$DEVICE/$FIRMWARE_LOCAL"
	
	pnn "- Ready for commissioning : "
	run rm -rf $IOT_FW_DIR/tmp.img
	cp $IOT_BUILD_DIR/$DEVICE/$FIRMWARE_LOCAL $IOT_FW_DIR/tmp.img
	FIRMWARE_NAME_FINAL=$IOT_FW_DIR/$DEVICE/$FIRMWARE_LOCAL
	FIRMWARE_NAME=$IOT_FW_DIR/tmp.img
	pg "Yes"
fi

pl
pg ":: Domain Selection ::"
pl

DOMAIN=$(domain)

if [ -z "$DOMAIN" ] || [ ! -d $MASTER_DB/$DOMAIN ]; then

	if [ "x$ADMIN" == "x1" ]; then

		CUST_WILDCARD="*** All Customers IDs and Site IDs (dangerous) ***"
		select_domain_cust "$CUST_WILDCARD"
		pl

		if [ ! -z "$CUST" ]; then
			SITE_WILDCARD="*** All Site IDs for selected Customer ID (dangerous) ***"
			select_domain_site "$SITE_WILDCARD"
			pl

			pnn "- Domain selected : "
			if [ -z "$SITE" ]; then
				pg "$CUST/*"
			else
				pg "$CUST/$SITE"
			fi
			pl
		else
			SITE=
			pnn "- Domain selected : "
			pg "*/*"
			pl
		fi

		domain_iterate
	else
		pl
		pr "No default domain is set. Without Admin mode we cannot proceed."
		pl
		exit 1
	fi
else
	# Single Default domain (Non-admin mode compatible)
	DOMAINS=($DOMAIN)
	pnn "- Domain selected : "
	pg "$DOMAIN"
	pl
fi

pg ":: Domain Settings Verification ::"
pl


DOMAINS_MAX=${#DOMAINS[@]}
DOMAINS_COUNT=0

while [ $DOMAINS_COUNT -lt $DOMAINS_MAX ] ; do

	DOMAIN_NEXT=${DOMAINS[$DOMAINS_COUNT]}

	CUST=$(dirname $DOMAIN_NEXT)
	SITE=$(basename $DOMAIN_NEXT)
	
	pnn "- Domain ($DOMAIN_NEXT) settings location valid : "
	if [ -d $MASTER_DB/$DOMAIN_NEXT/settings ]; then
		pg "Yes"
	else
		pr "No"
		pl
		pr "Error: Settings folder does not exist"
		exit 1
	fi
	
	pnn "- Domain ($DOMAIN_NEXT) Netplan verification : "
	netplan_verify $CUST $SITE
	pg "Done"

	DOMAINS_COUNT=$((DOMAINS_COUNT + 1))
done

pl
pg ":: Domain Settings Cloud Update ::"
pl

DOMAINS_COUNT=0

while [ $DOMAINS_COUNT -lt $DOMAINS_MAX ] ; do

	DOMAIN_NEXT=${DOMAINS[$DOMAINS_COUNT]}

	CUST=$(dirname $DOMAIN_NEXT)
	SITE=$(basename $DOMAIN_NEXT)

	pnn "- Domain ($DOMAIN_NEXT) publish settings : "
	update_settings_check
	pg "Done"

	pnn "- Domain ($DOMAIN_NEXT) change status : "
	pg "$SETTINGS_UPDATE_STATUS"
	
	DOMAINS_COUNT=$((DOMAINS_COUNT + 1))

done

pl
pg ":: Domain Payload Verification ::"
pl

DOMAINS_MAX=${#DOMAINS[@]}
DOMAINS_COUNT=0

while [ $DOMAINS_COUNT -lt $DOMAINS_MAX ] ; do

	DOMAIN_NEXT=${DOMAINS[$DOMAINS_COUNT]}

	CUST=$(dirname $DOMAIN_NEXT)
	SITE=$(basename $DOMAIN_NEXT)
	
	pnn "- Domain ($DOMAIN_NEXT) payload location valid : "
	if [ -d $MASTER_DB/$DOMAIN_NEXT/payload ]; then
		pg "Yes"
	else
		pr "No"
		pl
		pr "Error: Payload folder does not exist"
		exit 1
	fi
	
	pnn "- Domain ($DOMAIN_NEXT) payload size check : "
	S=$(du -hs --block-size=1M $MASTER_DB/$CUST/$SITE/payload | sed -n 's/^\([0-9.]*\).*/\1/p')
	if [ $S -gt $FIRMWARE_PAYLOAD_MAX_SIZE ]; then
		pr "Fail"
		pl
		pr "Payload exceeds ${FIRMWARE_PAYLOAD_MAX_SIZE}MiB ($CUST/$SITE/payload)"
		
		log "Payload exceeds ${FIRMWARE_PAYLOAD_MAX_SIZE}MiB ($CUST/$SITE/payload)"
		
		exit 1
	fi
	pg "Done"

	DOMAINS_COUNT=$((DOMAINS_COUNT + 1))
done

pl
pg ":: Domain Payload Cloud Update ::"
pl

DOMAINS_COUNT=0

while [ $DOMAINS_COUNT -lt $DOMAINS_MAX ] ; do

	DOMAIN_NEXT=${DOMAINS[$DOMAINS_COUNT]}

	CUST=$(dirname $DOMAIN_NEXT)
	SITE=$(basename $DOMAIN_NEXT)

	pnn "- Domain ($DOMAIN_NEXT) publish payload : "
	update_payload_check
	pg "Done"

	pnn "- Domain ($DOMAIN_NEXT) change status : "
	pg "$PAYLOAD_UPDATE_STATUS"
	
	DOMAINS_COUNT=$((DOMAINS_COUNT + 1))

done

pl
echo ">> $FIRMWARE_NAME <<"
echo ">> $FIRMWARE_NAME_FINAL <<"
exit 1


pl
pnn "- Image selected : "
pg $IMAGE_INPUT
pnn "- Customer selected : "
pg $CUST_INPUT
pnn "- Site selected : "
pg $SITE_INPUT
pl

echo "[$(date)] Commissioning Details [$IMAGE_INPUT, $CUST_INPUT, $SITE_INPUT]" >> $LOG

pnn "- Creating target image : "
IMAGE_INPUT_NEW="$S3_SOURCE/$CUST_INPUT/$SITE_INPUT/$(echo $(basename $IMAGE_INPUT) | sed -n 's/^\(.*\).img/\1/p')-commissioned-$CUST_INPUT-$SITE_INPUT-${COMM_VERSION}_${DATE}.img"
run cp -f $IMAGE_INPUT $IMAGE_INPUT_NEW
IMAGE_INPUT=$IMAGE_INPUT_NEW
pg "DONE"

pnn "- Output Image : "
pg $IMAGE_INPUT

pnn "- Checking if settings is available : "
if [ -d $S3_SOURCE/$CUST_INPUT/$SITE_INPUT/settings ]; then
	pg "PASS"
else
	pr "FAIL"
	pl
	pr "Settings does not exist ($CUST_INPUT/$SITE_INPUT/settings)"
	pl
	pn "Please create settings (Customer: $CUST_INPUT, Site: $SITE_INPUT)"
	exit 1
fi

pnn "- Checking if WIFI is customer specific : "
if [ -f $S3_SOURCE/$CUST_INPUT/$SITE_INPUT/settings/.wifi ]; then
	cat $S3_SOURCE/$CUST_INPUT/$SITE_INPUT/settings/.wifi | grep "TEST-SSID" > /dev/null 2>&1
	RET=$?
	if [ $RET -eq 0 ]; then
		pr "FAIL"
		pl
		pr "WIFI settings not site specific - remove unused ($CUST_INPUT/$SITE_INPUT/settings/.wifi)"
		pl
		pn "Please edit WIFI settings (Customer: $CUST_INPUT, Site: $SITE_INPUT)"
		exit 1
	fi
	pg "PASS"
else
	pr "FAIL"
	pl
	pr "WIFI settings does not exist ($CUST_INPUT/$SITE_INPUT/settings/.wifi)"
	pl
	pn "Please create settings (Customer: $CUST_INPUT, Site: $SITE_INPUT)"
	exit 1
fi

pnn "- Checking WIFI settings : "
mkdir -p /tmp/testyaml
/lib/netplan/generate -r /tmp/testyaml $S3_SOURCE/$CUST_INPUT/$SITE_INPUT/settings/.wifi
RET=$?
if [ $RET -ne 0 ]; then
	pr "FAIL"
	pl
	pr "Wifi settings invalid for Netplan ($CUST_INPUT/$SITE_INPUT/settings/.wifi)"
	
	echo "[$(date)] Wifi settings invalid ($CUST_INPUT/$SITE_INPUT/settings/.wifi)" >> $LOG
	
	exit 1
fi
pg "DONE"
rm -rf /tmp/testyaml

pnn "- Checking payload : "
if [ ! -d $S3_SOURCE/$CUST_INPUT/$SITE_INPUT/payload ]; then
	pg "NOT SUPPLIED"
else
	
	if [ -z "$(ls -A $S3_SOURCE/$CUST_INPUT/$SITE_INPUT/payload)" ]; then
		pr "FAIL"
		pl
		pr "Empty payload folder not allowed ($CUST_INPUT/$SITE_INPUT/payload)"
		pl
		pn "Delete the folder or add payload files."
		exit 1
	fi
	
	S=$(du -hs --block-size=1M $S3_SOURCE/$CUST_INPUT/$SITE_INPUT/payload | sed -n 's/^\([0-9.]*\).*/\1/p')
	if [ $S -gt $PAYLOAD_MAX_SIZE ]; then
		pr "FAIL"
		pl
		pr "Playlists exceed ${PAYLOAD_MAX_SIZE}Mib ($CUST_INPUT/$SITE_INPUT/payload)"
		exit 1
	fi
fi



echo "[$(date)] Commissioning checks OK" >> $LOG

		
pnn "- Syncing cloud with payload data : "

PAYLOAD_UPDATE=$(s3cmd -v --config $S3_ALL --no-check-md5 sync --no-preserve --delete-removed $S3_SOURCE/$CUST_INPUT/$SITE_INPUT/payload/ $S3_DEVICE_DL/$CUST_INPUT/$SITE_INPUT/payload/ 2>&1)
PAYLOAD_UPDATE_RET=$?

if [ $PAYLOAD_UPDATE_RET -ne 0 ]; then
	pl
	pr "PAYLOAD: Upload failed (Ret: $PAYLOAD_UPDATE_RET)"
	exit 1
fi		

pg "DONE"

pnn "- Syncing cloud with settings : "

SETTINGS_UPDATE=$(s3cmd -v --config $S3_ALL sync --no-preserve $S3_SOURCE/$CUST_INPUT/$SITE_INPUT/settings/ $S3_DEVICE_DL/$CUST_INPUT/$SITE_INPUT/settings/ 2>&1)
SETTINGS_UPDATE_RET=$?
	
if [ $SETTINGS_UPDATE_RET -ne 0 ]; then
	pl
	pr "SETTINGS: Upload failed (Ret: $SETTINGS_UPDATE_RET)"
	exit 1
fi	

# Set commissioned flag under stats
mkdir -p $S3_SOURCE/$CUST_INPUT/$SITE_INPUT/	
if [ ! -f $S3_SOURCE/$CUST_INPUT/$SITE_INPUT/.commissioned ]; then
	touch $S3_SOURCE/$CUST_INPUT/$SITE_INPUT/.commissioned
	run s3cmd -v --config $S3_ALL put --no-preserve $S3_SOURCE/$CUST_INPUT/$SITE_INPUT/.commissioned $S3_DEVICE_UL/$CUST_INPUT/$SITE_INPUT/
fi

pg "DONE"

pnn "- Mounting root filesystem : "

LOOPDEV=$(losetup --show -P -f $IMAGE_INPUT)
mkdir -p $CPWD/mnt/boot
mkdir -p $CPWD/mnt/enc
mkdir -p $CPWD/mnt/root
mount -o rw ${LOOPDEV}p4 $CPWD/mnt/enc
mount -o rw ${LOOPDEV}p2 $CPWD/mnt/root
mount -o rw ${LOOPDEV}p1 $CPWD/mnt/boot

pg "DONE"

# We need to commission this image to match a customer::site

pnn "- Inserting Customer and Site ID : "
mkdir -p $CPWD/mnt/boot/iot/commission
echo "$CUST_INPUT" > $CPWD/mnt/boot/iot/commission/.cust
echo "$SITE_INPUT" > $CPWD/mnt/boot/iot/commission/.site
pg "DONE"

pnn "- Hostname : "
run sed -i "s/HOSTNAMEXXX/RPI-$(echo $CUST_INPUT | sed 's/cust-//g')-$(echo $SITE_INPUT | sed 's/site-//g')/g" $CPWD/mnt/boot/user-data
pg "DONE"

pnn "- Inserting S3 Keys : "
run cp -f $CPWD/security/s3/.s3cfg-download $CPWD/mnt/boot/iot/commission/.s3cfg-download
run cp -f $CPWD/security/s3/.s3cfg-upload $CPWD/mnt/boot/iot/commission/.s3cfg-upload
pg "DONE"


pnn "- Installing unit settings (i.e. wifi) : "
mkdir -p $CPWD/mnt/boot/iot
run cp -Rf $S3_SOURCE/$CUST_INPUT/$SITE_INPUT/settings $CPWD/mnt/boot/iot/
echo "-1" > $CPWD/mnt/boot/iot/settings/.version
pg "DONE"


pnn "- Payload pre-commissioning : "

if [ "x$SKIP_PAYLOAD" == "xfalse" ]; then
	mkdir -p $CPWD/mnt/enc/live/payload
	mkdir -p $CPWD/mnt/enc/update/payload
        run cp -Rf $S3_SOURCE/$CUST_INPUT/$SITE_INPUT/payload/* $CPWD/mnt/enc/live/payload/
        run cp -Rf $S3_SOURCE/$CUST_INPUT/$SITE_INPUT/payload/* $CPWD/mnt/enc/update/payload/
	run touch $CPWD/mnt/boot/iot/.enc-formatted
	pg "DONE"
else
	pg "SKIPPED"
fi

if [ "x$DEBUG_SHELL" == "xtrue" ]; then
	
	pnn "- Preparing for foreign chroot : "
	
	mount --bind /dev $CPWD/mnt/root/dev/
	mount --bind /sys $CPWD/mnt/root/sys/
	mount --bind /proc $CPWD/mnt/root/proc/
	mount --bind /dev/pts $CPWD/mnt/root/dev/pts
	mkdir -p $CPWD/mnt/root/boot/firmware
	mount --bind $CPWD/mnt/boot $CPWD/mnt/root/boot/firmware
        
        mkdir -p $CPWD/mnt/root/home/iot/enc_drive
        mount --bind $CPWD/mnt/enc $CPWD/mnt/root/home/iot/enc_drive  
	
	cp -f /usr/bin/qemu-aarch64-static $CPWD/mnt/root/usr/bin/
	
	pg "DONE"
	
	pn
	pg "Foreign chroot start"
	pn
	
	chroot $CPWD/mnt/root /bin/bash 
	
	pn
	pg "Foreign chroot end"
	pn
	
	pnn "- Cleaning up chroot : "
	
	rm -f $CPWD/mnt/root/usr/bin/qemu-aarch64-static
	
	sync
	
        umount $CPWD/mnt/root/home/iot/enc_drive
        rm -rf $CPWD/mnt/root/home/iot/enc_drive
	umount $CPWD/mnt/root/boot/firmware
	umount $CPWD/mnt/root/dev/pts
	umount $CPWD/mnt/root/dev/
	umount $CPWD/mnt/root/sys/
	umount $CPWD/mnt/root/proc/
	
	pg "DONE"
	
	
fi

pnn "- Waiting for depedencies (5sec) : "
sync
sleep 5
pg "OK"

pnn "- Unmounting root filesystem : "
cd $CPWD/
umount ${LOOPDEV}p1
umount ${LOOPDEV}p2
umount ${LOOPDEV}p4
rm -d $CPWD/mnt/boot
rm -d $CPWD/mnt/root
rm -d $CPWD/mnt/enc
pg "DONE"

pnn "- Waiting for depedencies (5sec) : "
sync
sleep 5
run losetup -d ${LOOPDEV}
pg "OK"

pl
pg "Image Ready: $IMAGE_INPUT"
pl
