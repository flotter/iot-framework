#!/bin/bash -e

#----------------------------------------------------#
# COMMON DEFINES                                     #
#----------------------------------------------------#

if [ -z "$SUDO_USER" ]; then
	USER=$(whoami)
else
	USER=$SUDO_USER
fi

DATE=$(date +"%d_%m_%y__%H_%M_%S")

# MiB
FIRMWARE_PAYLOAD_MAX_SIZE=32

#----------------------------------------------------#
# LOCAL DIRECTORIES                                  #
#----------------------------------------------------#

REPO_ROOT=$( cd -- "$( dirname -- "${BASH_SOURCE[0]}" )" &> /dev/null && cd .. && pwd )
MASTER_DB=$REPO_ROOT/database
TOOL_SETTINGS=/home/$USER/.iot-tools/settings
IOT_DEVICE_DIR=$REPO_ROOT/iot
IOT_FW_DIR=$REPO_ROOT/firmware
IOT_BUILD_DIR=$REPO_ROOT/build
IOT_DOWNLOAD_DIR=$REPO_ROOT/download

#----------------------------------------------------#
# PRINTING ROUTINES                                  #
#----------------------------------------------------#

P_RESET="\e[0m"
P_RED="\e[31m"
P_GREEN="\e[32m"

function pl() {
	echo -e "$P_RESET"
}

function pn() {
	echo -e "$P_RESET$@"
}

function pr() {
	echo -e "$P_RED$@$P_RESET"
}

function pg() {
	echo -e "$P_GREEN$@$P_RESET"
}

function pnn() {
	echo -ne "$P_RESET$@"
}

function prn() {
	echo -ne "$P_RED$@$P_RESET"
}

function pgn() {
	echo -ne "$P_GREEN$@$P_RESET"
}

function log() {
	echo "[$(date) - $VERSION] $@" >> $LOG
}

#----------------------------------------------------#
# VERBOSITY CONTROL                                  #
#----------------------------------------------------#

run() {
        if $VERBOSE; then
                v=$(exec 2>&1 && set -x && set -- "$@")
                echo "#${v#*--}"
                "$@"
        else
                "$@" >/dev/null 2>&1
        fi
}

#----------------------------------------------------#
# SETUP ROUTINES                                     #
#----------------------------------------------------#

common_setup() {

	pnn "- Running as user : "
        pg $USER
	
	pnn "- Running with Sudo : "
	ID=$(id -u)
	if [ "x$ID" == "x0" ]; then
	    pg "Yes"
	else
	    pr "No"
	    exit 1
	fi

        pnn "- Apply environment override settings : "
        mkdir -p $(dirname $TOOL_SETTINGS)
        touch $TOOL_SETTINGS
        if [ -v IOT_DOMAIN ]; then
                if [ ! -d $MASTER_DB/$IOT_DOMAIN ]; then
			pr "Fail"
			pl
			pr "Domain does not exist. Please create it first."
			exit 1
		fi
        	sed -i '/IOT_DOMAIN/d' $TOOL_SETTINGS
                echo "IOT_DOMAIN=$IOT_DOMAIN" >> $TOOL_SETTINGS
	fi
        if [ -v IOT_DEVICE ]; then
                if [ ! -d $IOT_DEVICE_DIR/$IOT_DEVICE ]; then
			pr "Fail"
			pl
			pr "Support for device $IOT_DEVICE does not exist. Did you spell it correctly?"
			exit 1
		fi
        	sed -i '/IOT_DEVICE/d' $TOOL_SETTINGS
                echo "IOT_DEVICE=$IOT_DEVICE" >> $TOOL_SETTINGS
	fi
        if [ -v IOT_ADMIN ]; then
        	sed -i '/IOT_ADMIN/d' $TOOL_SETTINGS
                echo "IOT_ADMIN=$IOT_ADMIN" >> $TOOL_SETTINGS
	fi
        pg "Done"
	
	pnn "- Installing missing components : "
	run sudo apt-get install -y git build-essential bison flex p7zip-full squashfs-tools pv bc device-tree-compiler libssl-dev qemu-user-static binfmt-support sshpass lvm2 kpartx uuid-dev ntpdate
	run apt-get install -y python3-pip
	run python3 -m pip install --upgrade pip
	run python3 -m pip install s3cmd
	pg "Done"
	
	pnn "- NTP Syncing clock : "
	run ntpdate ntp.is.co.za
	pg "Done"
	
	pnn "- Disabling automount : "
	gsettings set org.gnome.desktop.media-handling automount false > /dev/null 2>&1
	pg "Done"
}


#----------------------------------------------------#
# VERSIONING                                         #
#----------------------------------------------------#

which git > /dev/null 2>&1
GIT_RET=$?
if [ $GIT_RET -ne 0 ]; then
	pn
	pr "Cannot find git tool"
	pn
	exit 1
fi
GITHASH=$(cd $REPO_ROOT && git rev-parse --short HEAD)
GIT_RET=$?
if [ $GIT_RET -ne 0 ]; then
	pn
	pr "Cannot find IOT git repo hash"
	pn
	exit 1
fi
GITTAG=$(cd $REPO_ROOT && git describe --tags --abbrev=0)
GIT_RET=$?
if [ $GIT_RET -ne 0 ]; then
	pn
	pr "Cannot find IOT git repo hash"
	pn
	exit 1
fi

VERSION="$GITTAG-$GITHASH"


#----------------------------------------------------#
# AWS S3 DEFINES                                     #
#----------------------------------------------------#

S3_ALL=$REPO_ROOT/security/s3/.s3cfg-all
S3_DEVICE_FW="s3://iot-device-fw"
S3_DEVICE_DL="s3://iot-device-download"
S3_DEVICE_UL="s3://iot-device-upload"

update_settings_check() {
	SETTINGS_UPDATE=$(s3cmd -v --config $S3_ALL sync --no-preserve --delete-removed $MASTER_DB/$CUST/$SITE/settings/ $S3_DEVICE_DL/$CUST/$SITE/settings/ 2>&1)
	SETTINGS_UPDATE_RET=$?

	if [ $SETTINGS_UPDATE_RET -ne 0 ]; then
		pr "Fail"
	        pl 
	        pr "Settings update for domain $CUST/$SITE failed (Ret: $SETTINGS_UPDATE_RET)"

		log "Settings update for domain $CUST/$SITE failed (Ret: $SETTINGS_UPDATE_RET)"
	        exit 1 
	fi

	S1=$(echo $SETTINGS_UPDATE | grep 'Summary:' | sed -n 's/.*Summary: \([^ ]*\).*/\1/p')
	S2=$(echo $SETTINGS_UPDATE | grep 'Summary:' | sed -n 's/.*upload, \([^ ]*\).*/\1/p')
	S3=$(echo $SETTINGS_UPDATE | grep 'Summary:' | sed -n 's/.*copy, \([^ ]*\).*/\1/p')

	OVER=$(cat $MASTER_DB/$CUST/$SITE/settings/.version)

	if [ "x$S1" != "x0" ] || [ "x$S2" != "x0" ] || [ "x$S3" != "x0" ]; then
		
	        NVER=$((OVER + 1))
	        echo $NVER > $MASTER_DB/$CUST/$SITE/settings/.version
	        
		run s3cmd -v --config $S3_ALL sync --no-preserve $MASTER_DB/$CUST/$SITE/settings/ $S3_DEVICE_DL/$CUST/$SITE/settings/
		SETTINGS_UPDATE_RET=$?

		if [ $SETTINGS_UPDATE_RET -ne 0 ]; then
			pr "Fail"
		        pl 
		        pr "Settings update for domain $CUST/$SITE failed (Ret: $SETTINGS_UPDATE_RET)"
	
			log "Settings update for domain $CUST/$SITE failed (Ret: $SETTINGS_UPDATE_RET)"
		        exit 1 
	        fi

		SETTINGS_UPDATE_STATUS="Updated (v$OVER -> v$NVER)"
	else
		SETTINGS_UPDATE_STATUS="No Change (v$OVER)"
	fi
}

update_payload_check() {
	PAYLOAD_UPDATE=$(s3cmd -v --config $S3_ALL sync --no-preserve --delete-removed $MASTER_DB/$CUST/$SITE/payload/ $S3_DEVICE_DL/$CUST/$SITE/payload/ 2>&1)
	PAYLOAD_UPDATE_RET=$?

	if [ $PAYLOAD_UPDATE_RET -ne 0 ]; then
		pr "Fail"
	        pl 
	        pr "Payload update for domain $CUST/$SITE failed (Ret: $PAYLOAD_UPDATE_RET)"

		log "Payload update for domain $CUST/$SITE failed (Ret: $PAYLOAD_UPDATE_RET)"
	        exit 1 
	fi

	P1=$(echo $PAYLOAD_UPDATE | grep 'Summary:' | sed -n 's/.*Summary: \([^ ]*\).*/\1/p')
	P2=$(echo $PAYLOAD_UPDATE | grep 'Summary:' | sed -n 's/.*upload, \([^ ]*\).*/\1/p')
	P3=$(echo $PAYLOAD_UPDATE | grep 'Summary:' | sed -n 's/.*copy, \([^ ]*\).*/\1/p')

	OVER=$(cat $MASTER_DB/$CUST/$SITE/payload/.version)

	if [ "x$P1" != "x0" ] || [ "x$P2" != "x0" ] || [ "x$P3" != "x0" ]; then
		
	        NVER=$((OVER + 1))
	        echo $NVER > $MASTER_DB/$CUST/$SITE/payload/.version
	        
		run s3cmd -v --config $S3_ALL sync --no-preserve --delete-removed $MASTER_DB/$CUST/$SITE/payload/ $S3_DEVICE_DL/$CUST/$SITE/payload/
		PAYLOAD_UPDATE_RET=$?

		if [ $PAYLOAD_UPDATE_RET -ne 0 ]; then
			pr "Fail"
		        pl 
		        pr "Payload update for domain $CUST/$SITE failed (Ret: $PAYLOAD_UPDATE_RET)"
	
			log "Payload update for domain $CUST/$SITE failed (Ret: $PAYLOAD_UPDATE_RET)"
		        exit 1 
	        fi

		PAYLOAD_UPDATE_STATUS="Updated (v$OVER -> v$NVER)"
	else
		PAYLOAD_UPDATE_STATUS="No Change (v$OVER)"
	fi
}

#----------------------------------------------------#
# COMMON CHECKS                                      #
#----------------------------------------------------#

admin() {
	if [ -f $TOOL_SETTINGS ]; then
		cat $TOOL_SETTINGS | grep "^IOT_ADMIN=" | sed -n 's/[^=]*=\(.*\)/\1/p' | xargs || true
	fi
}

admin_check() {
	if [ "x$(admin)" != "x1" ]; then
		pr "No"
		exit 1
	fi
}

domain() {
	if [ -f $TOOL_SETTINGS ]; then
		cat $TOOL_SETTINGS | grep "^IOT_DOMAIN=" | sed -n 's/[^=]*=\(.*\)/\1/p' | xargs || true
	fi
}

domain_check() {
	if [ -z "$(domain)" ]; then
		pr "Fail"
	        pl
	        pr "Error: No default domain is set. Please set it first"
	        pl
	        exit 1
	fi
	if [ ! -d "$MASTER_DB/$(domain)" ]; then
		pr "Fail"
	        pl
	        pr "Error: Domain does not exist. Please check the spelling."
	        pl
	        exit 1
	fi
}

device() {
	if [ -f $TOOL_SETTINGS ]; then
		cat $TOOL_SETTINGS | grep "^IOT_DEVICE=" | sed -n 's/[^=]*=\(.*\)/\1/p' | xargs || true
	fi
}

device_check() {
	if [ -z "$(device)" ]; then
		pr "Fail"
	        pl
	        pr "Error: No default device is set. Please set it first"
	        pl
	        exit 1
	fi
	if [ ! -d "$IOT_DEVICE_DIR/$(device)" ]; then
		pr "Fail"
	        pl
	        pr "Error: Device does not exist. Please check the spelling."
	        pl
	        exit 1
	fi
}

netplan_verify() {
	local NPVER=$(mktemp -d)
	/lib/netplan/generate -r $NPVER $MASTER_DB/$1/$2/settings/.wifi
	RET=$?

	rm -rf $NPVER

	if [ $RET -ne 0 ]; then
	        pr "Fail"
	        pl
	        pr "Wifi settings invalid ($1/$2/settings/.wifi)"
	        log "Wifi settings invalid ($1/$2/settings/.wifi)"
	
	        exit 1
	fi
}

select_domain_cust() {
	
	log "Selecting Customer ID"
	
	EXTRA="$1"
	mkdir -p $MASTER_DB
	if [ -z "$EXTRA" ]; then
		CUST_LIST=($(ls $MASTER_DB | grep cust- || true))
	else
		CUST_LIST=("$EXTRA" $(ls $MASTER_DB | grep cust- || true))
	fi
	CUST_LIST_MAX=${#CUST_LIST[@]}
	SELECT=$CUST_LIST_MAX
	ITER=0

	while [ $SELECT -lt 0 ] || [ $SELECT -ge $CUST_LIST_MAX ] ; do
	
	        if [ $CUST_LIST_MAX -eq 0 ]; then
	                break
	        fi
	
	        if [ $ITER -ne 0 ]; then
	                pl
	                pr "Error: Your choice is invalid!"
	                pl
	        fi
	
	        pn "Please select the Customer ID from the list:"
	        COUNT=0
	        while [ $COUNT -lt $CUST_LIST_MAX ]; do
	                pn "[$(printf "%2d" $((COUNT + 1)))] ${CUST_LIST[$COUNT]}"
	                COUNT=$((COUNT + 1))
	        done
	
	        pl
	        pnn "Choice? : "
	        read SELECT
	        SELECT=$((SELECT - 1))
	        ITER=$((ITER + 1))
	done
	CUST=${CUST_LIST[$SELECT]}
	
	if [ -z "$CUST" ]; then
	        pl
	        pr "Error: No valid Customer ID found! Please create a new Customer ID"
	        pl
	        exit 1
	fi

	if [ "$CUST" = "$EXTRA" ]; then
		# This is a wildcard, so empty
		CUST=
	fi
}

select_domain_site() {

	log "Selecting Site ID"

	EXTRA="$1"
	mkdir -p $MASTER_DB/$CUST
	if [ -z "$EXTRA" ]; then
		SITE_LIST=($(ls $MASTER_DB/$CUST | grep site- || true))
	else
		SITE_LIST=("$EXTRA" $(ls $MASTER_DB/$CUST | grep site- || true))
	fi
	SITE_LIST_MAX=${#SITE_LIST[@]}
	SELECT=$SITE_LIST_MAX
	ITER=0
	
	while [ $SELECT -lt 0 ] || [ $SELECT -ge $SITE_LIST_MAX ]; do
	
	        if [ $SITE_LIST_MAX -eq 0 ]; then
	                break
	        fi
	
	        if [ $ITER -ne 0 ]; then
	                pl
	                pr "Error: Your choice is invalid!"
	                pl
	        fi
	
	        pn "Please select the Site ID from the list:"
	        COUNT=0
	        while [ $COUNT -lt $SITE_LIST_MAX ]; do
	                pn "[$(printf "%2d" $((COUNT + 1)))] ${SITE_LIST[$COUNT]}"
	                COUNT=$((COUNT + 1))
	        done
	
	        pl
	        pnn "Choice? : "
	        read SELECT
	        SELECT=$((SELECT - 1))
	        ITER=$((ITER + 1))
	done
	SITE=${SITE_LIST[$SELECT]}
	
	if [ -z "$SITE" ]; then
	        pl
	        pr "Error: No valid Site ID found! Please create a new Site ID"
	        pl
	        exit 1
	fi
	
	if [ "$SITE" = "$EXTRA" ]; then
		# This is a wildcard, so empty
		SITE=
	fi
}

select_domain() {
	select_domain_cust
	select_domain_site
}

domain_iterate() {
	
	log "Domain Iterate: CUST=$CUST, SITE=$SITE"

	DOMAINS=()
	
	mkdir -p $MASTER_DB
	CUST_LIST=($(ls $MASTER_DB | grep cust- || true))
	CUST_LIST_MAX=${#CUST_LIST[@]}
	CUST_COUNT=0
	
	while [ $CUST_COUNT -lt $CUST_LIST_MAX ] ; do
	
		CUST_NEXT=${CUST_LIST[$CUST_COUNT]}
	
		if [ -z "$CUST" ] || [ "$CUST_NEXT" = "$CUST" ]; then

			mkdir -p $MASTER_DB/$CUST_NEXT
			SITE_LIST=($(ls $MASTER_DB/$CUST_NEXT | grep site- || true))
			SITE_LIST_MAX=${#SITE_LIST[@]}
			SITE_COUNT=0

			while [ $SITE_COUNT -lt $SITE_LIST_MAX ] ; do

				SITE_NEXT=${SITE_LIST[$SITE_COUNT]}

				if [ -z "$SITE" ] || [ "$SITE_NEXT" = "$SITE" ]; then
					DOMAINS+=("$CUST_NEXT/$SITE_NEXT")
				fi

				SITE_COUNT=$((SITE_COUNT + 1))
			done
		fi

	        CUST_COUNT=$((CUST_COUNT + 1))
	done
}

select_device() {
	
	log "Selecting Device"
	
	mkdir -p $IOT_DEVICE_DIR
	DEVICE_LIST=($(ls $IOT_DEVICE_DIR | grep device- || true))
	DEVICE_LIST_MAX=${#DEVICE_LIST[@]}
	SELECT=$DEVICE_LIST_MAX
	ITER=0
	
	while [ $SELECT -lt 0 ] || [ $SELECT -ge $DEVICE_LIST_MAX ] ; do
	
	        if [ $DEVICE_LIST_MAX -eq 0 ]; then
	                break
	        fi
	
	        if [ $ITER -ne 0 ]; then
	                pl
	                pr "Error: Your choice is invalid!"
	                pl
	        fi
	
	        pn "Please select the device from the list:"
	        COUNT=0
	        while [ $COUNT -lt $DEVICE_LIST_MAX ]; do
	                pn "[$(printf "%2d" $((COUNT + 1)))] ${DEVICE_LIST[$COUNT]}"
	                COUNT=$((COUNT + 1))
	        done
	
	        pl
	        pnn "Choice? : "
	        read SELECT
	        SELECT=$((SELECT - 1))
	        ITER=$((ITER + 1))
	done
	DEVICE=${DEVICE_LIST[$SELECT]}
	
	if [ -z "$DEVICE" ]; then
	        pl
	        pr "Error: No valid device found! Internal error."
	        pl
	        exit 1
	fi
}

select_remote_fw() {

	log "Selecting Remote FW"

	EXTRA="$1"
	FIRMWARES_REMOTE=()
	REMOTE=($(s3cmd --config $S3_ALL ls $S3_DEVICE_FW/$DEVICE/ | sed -n 's/.*\(s3:\/\/.*.tar.gz$\)/\1/p'))
	if [ ! -z "$EXTRA" ]; then
		FIRMWARES_REMOTE+=("$EXTRA")	
	fi
	if [ ${#REMOTE[@]} -gt 0 ]; then
		FIRMWARES_REMOTE+=($(echo ${REMOTE[@]} | xargs -n 1 basename | sed -n 's/.tar.gz//p'))
	fi

	FIRMWARES_REMOTE_MAX=${#FIRMWARES_REMOTE[@]}
	SELECT=$FIRMWARES_REMOTE_MAX
	ITER=0
	
	while [ $SELECT -lt 0 ] || [ $SELECT -ge $FIRMWARES_REMOTE_MAX ]; do
	
	        if [ $FIRMWARES_REMOTE_MAX -eq 0 ]; then
	                break
	        fi
	
	        if [ $ITER -ne 0 ]; then
	                pl
	                pr "Error: Your choice is invalid!"
	                pl
	        fi
	
	        pn "Please select remote firmware from the list:"
	        COUNT=0
	        while [ $COUNT -lt $FIRMWARES_REMOTE_MAX ]; do
	                pn "[$(printf "%2d" $((COUNT + 1)))] ${FIRMWARES_REMOTE[$COUNT]}"
	                COUNT=$((COUNT + 1))
	        done
	
	        pl
	        pnn "Choice? : "
	        read SELECT
	        SELECT=$((SELECT - 1))
	        ITER=$((ITER + 1))
	done
	FIRMWARE_REMOTE=${FIRMWARES_REMOTE[$SELECT]}
	
	if [ -z "$FIRMWARE_REMOTE" ]; then
	        pl
	        pr "Error: No valid remote firmware found."
	        pl
	        exit 1
	fi
	
	if [ "$FIRMWARE_REMOTE" = "$EXTRA" ]; then
		# This is an extra option, so empty
		FIRMWARE_REMOTE=
	fi
}

download_remote_fw_check() {
	FW=$1
	TARGET_DIR=$2
        run s3cmd --config $S3_ALL get $FW $TARGET_DIR
        RET=$?
        if [ $RET -ne 0 ]; then
		pr "Fail"
                pl
                pr "Remote firmware download failed (Ret: $RET)"
		pl

                exit 1
        fi
}
